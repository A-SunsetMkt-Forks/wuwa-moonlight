#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroAnim

#include "Basic.hpp"

#include "KuroAnim_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class KuroAnim.KuroAnimInstance
// 0x00E0 (0x0490 - 0x03B0)
class UKuroAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_1AB9[0x68];                                    // 0x03A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TurnLimitForBoneRotateAnimNode;                    // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookUpLimitForBoneRotateAnimNode;                  // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRollBackToOriginForBoneRotateAnimNode;            // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopForBoneRotateAnimNode;                        // 0x0421(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ABA[0x2];                                     // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAngleForBoneRotateAnimNode;                    // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAngleForBoneRotateAnimNode;                  // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOffsetForBoneRotateAnimNode;                   // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpOffsetForBoneRotateAnimNode;                 // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ABB[0x4];                                     // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAnimSequence*>       ExtraRibbonAnims;                                  // 0x0438(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ABC[0x8];                                     // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AngleConversion(const float& Angle);
	void BindBooleanVarToActorTag(bool& BooleanVarRef, class FName Tag);
	void BindBooleanVarToTag(bool& BooleanVarRef, const struct FGameplayTag& Tag);
	void BindComponentVarToAnimInstance(class UObject* Component, const class FString& ComponentVarName, const class FString& InstanceVarName);
	void BindEnumToRoleAnimInstance(class UObject* Component);
	void BindVarToCharacter(struct FVector& VelocityRef, struct FVector& ActorForwardVectorRef, struct FRotator& ActorRotationRef, struct FRotator& ControlRotationRef, struct FVector& CurrentAccelerationRef, bool& bMoveBlockRef);
	struct FVector2D CalculateAimMixed(const struct FVector& Speed, const struct FRotator& RoleRotator, class ACharacter* Character);
	struct FVector CalculateRelativeAcceleration(const struct FVector& Speed, const struct FVector& Acceleration, const struct FRotator& RoleRotator, class ACharacter* Character);
	void CalculateSpeedMixed(const struct FRotator& RoleRotator, const struct FRotator& AdditiveRotator, const struct FVector& Speed, class ACharacter* Character, class UCurveFloat*& Curve, const float& DeltaTime, float& CachedPercentFB, float& CachedPercentLR, struct FVeloctiyBlend& VelocityBlend);
	float CalculateStandRate(class UCurveFloat*& AngleToStepFrequency, const float& Slop, const float& Speed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, const float& StepLengthMix);
	float CalculateStepLengthMixed(class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& Speed, const float& Slop);
	float CalculateWalkRunMixed(const int32& MoveState);
	void CalucateClimbOffset(class ACharacter*& Character, const struct FVector& IKDirection, const struct FVector& OffsetRelativeLocation, const struct FVector& BoneLocation, float OffsetCorrection, float TraceRadius, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& CachedLocation, struct FVector& CachedNormal, const float& IKCurveValue, const float& ClimbRadius, float& PrevFrameAlpha, struct FVector* OutOffset, struct FVector* OutNormal, bool* bSuccess);
	void ClimbIKProcess(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, const bool& IsClimbExitState, struct FVector& OverallOffsetLocation, float& ClimbIK, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha);
	class FString GetDebugAnimNodeString();
	void GroundIKProcess(const struct FVector& MeshWorldLocation, const float& DegMovementSlop, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& bUpHill, const bool& bDownHill, const float& Speed, const bool& HasMoveInput, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation);
	void IKInfoLerpProcess(const float& DeltaTime, const float& HipLerpSpeed, const struct FRotator& QuatInverse, const struct FVector& OverallOffsetLocation, struct FVector& OverallOffsetLocationBeUsed, struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootNormalRelativeDirection, const struct FVector& LFootOffsetLocation, const struct FVector& LFootNormalDirection, struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootNormalRelativeDirection, const struct FVector& RFootOffsetLocation, const struct FVector& RFootNormalDirection, struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandNormalRelativeDirection, const struct FVector& LHandOffsetLocation, const struct FVector& LHandNormalDirection, struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandNormalRelativeDirection, const struct FVector& RHandOffsetLocation, const struct FVector& RHandNormalDirection);
	struct FLeanAmount InterpLeanAmountTo(const struct FLeanAmount& Current, const struct FLeanAmount& Target, float DeltaTime, float InterpSpeed);
	float IsContainExtraRibbonAnims();
	void OnComponentStart();
	void RegisterActor(class ACharacter* Character);
	void ResigterExtraRibbenOwnerAnimInstance(class UAnimInstance* AnimInstance);
	void SetBoneRotateToLocationInfoRunBegin(float TurnAngle, float LookUpAngle, const struct FVector2D& TurnLimit, const struct FVector2D& LookUpLimit, float TurnOffset, float LookUpOffset);
	void SetBoneRotateToLocationInfoRunEnd();
	void SetBoneRotateToLocationInfoRunTick(float TurnAngle, float LookUpAngle);
	void SetBoneRotateToLocationInfoStopBegin();
	void SetBoneRotateToLocationInfoStopEnd();
	void SetDebugTraceType(EDrawDebugTrace GroundTrace, EDrawDebugTrace ClimbTrace);
	void SetFootOffset(const struct FVector& SkeletionAbsoluteLocation, const struct FVector& IKDirection, const float& BenchMarkDepth, const float& RotationCorrectedDistance, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& HasMoveInput, bool& bNeedIK, struct FVector& OffsetLocation, struct FVector& NormalDirection, struct FHitResult& OutHitResult);
	void StartABP();
	void UnRegisterActorAndResetInstance();
	void UpdateABP(float DeltaSeconds);
	void UpdateAdditiveBlendInfo(class UAnimInstance* AnimInstance, const bool& bUsingAdditiveBlend, const bool& bUsingWholeBodyBlend, float& AdditiveBlendAlpha, struct FAdditiveBlendAlpha& Plevis, struct FAdditiveBlendAlpha& Spine, struct FAdditiveBlendAlpha& Head, struct FAdditiveBlendAlpha& ArmL, struct FAdditiveBlendAlpha& ArmR, struct FAdditiveBlendAlpha& Leg);
	void UpdateBattleIdle(const float& BattleIdleTime, bool& bBattleIdle);
	void UpdateBindRoleInfo();
	void UpdateBooleanVar();
	void UpdateCameraStateMoveInfo(const struct FVector& Speed, class ACharacter*& Character, const struct FRotator& RoleRotator, const struct FVector& Acceleration, float& RotatorMixed, const float& DeltaTime, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle);
	void UpdateCharacterVar();
	void UpdateIKinfoInClimbState(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& OverallOffsetLocation, float& ClimbIK, const float& FastClimbDirection, const bool& IsFastClimbState, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, float& HipLerpSpeed, const float& Speed, const bool& HasMoveInput, const bool& IsClimbExitState, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha);
	void UpdateIKInfoInGroundState(const bool& HasWallForward, const struct FVector& MeshWorldLocation, const bool& IsMoving, const float& DegMovementSlop, bool& bUpHill, bool& bDownHill, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& Speed, const bool& HasMoveInput, const float& RunWalkMix, struct FVector& OverallOffsetLocation, float& HipLerpSpeed, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation);
	void UpdateIKinfoInOtherState(class ACharacter*& Character, struct FVector& OverallOffsetLocation, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FVector& LHandNormalDirection, struct FVector& RHandNormalDirection, float& HipLerpSpeed);
	void UpdateIKInfoLocalValue(class ACharacter* Character, struct FRotator& MeshQuatInverse, struct FVector& MeshWorldLocation);
	void UpdateMoveInfoMixed(float& WalkRunMixed, const float& DeltaTime, const float& Slop, class UCurveFloat*& AngleToStepFrequency, class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& SpeedSize, float& StepLengthMixed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, float& StandRate);
	void UpdateRoleInfo(bool& StateGround, bool& StateGroundSprint, bool& StateGroundWalk, bool& StateGroundRun, bool& StateRunStop, bool& StateSprintStop, bool& StateWalkStop, bool& RunStop, bool& StateClimb, bool& StateAir, bool& StateAirGlide, bool& StateWater, bool& StateView, bool& StateAim, bool& StateFace);
	void UpdateSkillMoveInfo(const float& DeltaTime, const struct FRotator& RoleRotator, const struct FVector& Speed, class ACharacter*& Character, float& RotatorMixed, const struct FVector& Acceleration, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle, struct FVector2D& AimMoveMixed, const float& RotatorSpeed, class AActor* SkillTarget, const struct FVector& CachedActorLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstance">();
	}
	static class UKuroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstance>();
	}
};
static_assert(alignof(UKuroAnimInstance) == 0x000010, "Wrong alignment on UKuroAnimInstance");
static_assert(sizeof(UKuroAnimInstance) == 0x000490, "Wrong size on UKuroAnimInstance");
static_assert(offsetof(UKuroAnimInstance, TurnLimitForBoneRotateAnimNode) == 0x000410, "Member 'UKuroAnimInstance::TurnLimitForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpLimitForBoneRotateAnimNode) == 0x000418, "Member 'UKuroAnimInstance::LookUpLimitForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, bRollBackToOriginForBoneRotateAnimNode) == 0x000420, "Member 'UKuroAnimInstance::bRollBackToOriginForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, bStopForBoneRotateAnimNode) == 0x000421, "Member 'UKuroAnimInstance::bStopForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, TurnAngleForBoneRotateAnimNode) == 0x000424, "Member 'UKuroAnimInstance::TurnAngleForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpAngleForBoneRotateAnimNode) == 0x000428, "Member 'UKuroAnimInstance::LookUpAngleForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, TurnOffsetForBoneRotateAnimNode) == 0x00042C, "Member 'UKuroAnimInstance::TurnOffsetForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, LookUpOffsetForBoneRotateAnimNode) == 0x000430, "Member 'UKuroAnimInstance::LookUpOffsetForBoneRotateAnimNode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstance, ExtraRibbonAnims) == 0x000438, "Member 'UKuroAnimInstance::ExtraRibbonAnims' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceChar
// 0x00C0 (0x0550 - 0x0490)
class UKuroAnimInstanceChar : public UKuroAnimInstance
{
public:
	class UAbpLogicParams*                        LogicParams;                                       // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseCharacter*                         BaseCharacter;                                     // 0x0498(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ADF[0x8];                                     // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTime;                                         // 0x04A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityId;                                          // 0x04AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutonomousProxy;                                // 0x04B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE0[0x3];                                     // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x04B4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE1[0xC];                                     // 0x04C0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMovedLocation;                                  // 0x04CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE2[0xF];                                     // 0x04CD(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Acceleration;                                      // 0x04DC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorForward;                                      // 0x04E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE3[0x4];                                     // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnJumpSpeed;                                       // 0x04F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x04FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE4[0x33];                                    // 0x04FD(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LowerBodyRotator;                                  // 0x0530(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocationProxy;                                     // 0x053C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESightLockMode                                SightLockMode;                                     // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE5[0x7];                                     // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceChar">();
	}
	static class UKuroAnimInstanceChar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceChar>();
	}
};
static_assert(alignof(UKuroAnimInstanceChar) == 0x000010, "Wrong alignment on UKuroAnimInstanceChar");
static_assert(sizeof(UKuroAnimInstanceChar) == 0x000550, "Wrong size on UKuroAnimInstanceChar");
static_assert(offsetof(UKuroAnimInstanceChar, LogicParams) == 0x000490, "Member 'UKuroAnimInstanceChar::LogicParams' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, BaseCharacter) == 0x000498, "Member 'UKuroAnimInstanceChar::BaseCharacter' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, DeltaTime) == 0x0004A8, "Member 'UKuroAnimInstanceChar::DeltaTime' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, EntityId) == 0x0004AC, "Member 'UKuroAnimInstanceChar::EntityId' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bIsAutonomousProxy) == 0x0004B0, "Member 'UKuroAnimInstanceChar::bIsAutonomousProxy' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, Velocity) == 0x0004B4, "Member 'UKuroAnimInstanceChar::Velocity' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bIsMovedLocation) == 0x0004CC, "Member 'UKuroAnimInstanceChar::bIsMovedLocation' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, Acceleration) == 0x0004DC, "Member 'UKuroAnimInstanceChar::Acceleration' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, ActorForward) == 0x0004E8, "Member 'UKuroAnimInstanceChar::ActorForward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, OnJumpSpeed) == 0x0004F8, "Member 'UKuroAnimInstanceChar::OnJumpSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, bStunned) == 0x0004FC, "Member 'UKuroAnimInstanceChar::bStunned' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, LowerBodyRotator) == 0x000530, "Member 'UKuroAnimInstanceChar::LowerBodyRotator' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, LocationProxy) == 0x00053C, "Member 'UKuroAnimInstanceChar::LocationProxy' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceChar, SightLockMode) == 0x000548, "Member 'UKuroAnimInstanceChar::SightLockMode' has a wrong offset!");

// Class KuroAnim.KuroAdjustableBoxComponent
// 0x0030 (0x0540 - 0x0510)
class UKuroAdjustableBoxComponent final : public UBoxComponent
{
public:
	TArray<class FName>                           BindSocketNames;                                   // 0x0510(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AddExtent;                                         // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinExtent;                                         // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExtent;                                         // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustBoxType                                AdjustBoxType;                                     // 0x052C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE6[0x13];                                    // 0x052D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAdjustableBoxComponent">();
	}
	static class UKuroAdjustableBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAdjustableBoxComponent>();
	}
};
static_assert(alignof(UKuroAdjustableBoxComponent) == 0x000010, "Wrong alignment on UKuroAdjustableBoxComponent");
static_assert(sizeof(UKuroAdjustableBoxComponent) == 0x000540, "Wrong size on UKuroAdjustableBoxComponent");
static_assert(offsetof(UKuroAdjustableBoxComponent, BindSocketNames) == 0x000510, "Member 'UKuroAdjustableBoxComponent::BindSocketNames' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, AddExtent) == 0x000520, "Member 'UKuroAdjustableBoxComponent::AddExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, MinExtent) == 0x000524, "Member 'UKuroAdjustableBoxComponent::MinExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, MaxExtent) == 0x000528, "Member 'UKuroAdjustableBoxComponent::MaxExtent' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableBoxComponent, AdjustBoxType) == 0x00052C, "Member 'UKuroAdjustableBoxComponent::AdjustBoxType' has a wrong offset!");

// Class KuroAnim.AbpLogicParams
// 0x00E0 (0x0110 - 0x0030)
class UAbpLogicParams final : public UObject
{
public:
	bool                                          AcceptedNewBeHitRef;                               // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE7[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BeHitAnimRef;                                      // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnterFkRef;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoubleHitInAirRef;                                 // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE8[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BeHitDirectRef;                                    // 0x003C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeHitLocationRef;                                  // 0x0048(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeHitSocketNameRef;                                // 0x0054(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharMoveStateType                            CharMoveStateRef;                                  // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharPositionStateType                        CharPositionStateRef;                              // 0x0061(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharViewDirectionStateType                   CharCameraStateRef;                                // 0x0062(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE9[0x1];                                     // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleIdleTimeRef;                                 // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegMovementSlopeRef;                               // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightDirectRef;                                    // 0x006C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RagQuitStateRef;                                   // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJumpRef;                                         // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEA[0x2];                                     // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AccelerationRef;                                   // 0x007C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMovingRef;                                       // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEB[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRef;                                          // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InputDirectRef;                                    // 0x0090(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InputRotatorRef;                                   // 0x009C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsFallingIntoWaterRef;                             // 0x00A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEC[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundedTimeRef;                                   // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMoveInputRef;                                   // 0x00B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AED[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbInfoStruct                       ClimbInfoRef;                                      // 0x00B4(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FClimbStateStruct                      ClimbStateRef;                                     // 0x00C4(0x0003)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEE[0x1];                                     // 0x00C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbOnWallAngleRef;                               // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSwimOffsetRef;                               // 0x00CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSwimOffsetLerpSpeedRef;                      // 0x00D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlideForwardRef;                                   // 0x00D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlideSwitchThisFrameRef;                           // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlideStandModeRef;                                 // 0x00E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AEF[0x2];                                     // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpUpRateRef;                                     // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceExitStateStopRef;                             // 0x00E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF0[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SkillTarget;                                       // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastActiveSkillTime;                               // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SitDownDirect;                                     // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StandUpDirect;                                     // 0x0100(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSitDown;                                          // 0x0104(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInPerformingPlot;                               // 0x0105(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSequence;                                     // 0x0106(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSplineMove;                                   // 0x0107(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInUiCamera;                                     // 0x0108(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF1[0x7];                                     // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbpLogicParams">();
	}
	static class UAbpLogicParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbpLogicParams>();
	}
};
static_assert(alignof(UAbpLogicParams) == 0x000008, "Wrong alignment on UAbpLogicParams");
static_assert(sizeof(UAbpLogicParams) == 0x000110, "Wrong size on UAbpLogicParams");
static_assert(offsetof(UAbpLogicParams, AcceptedNewBeHitRef) == 0x000030, "Member 'UAbpLogicParams::AcceptedNewBeHitRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitAnimRef) == 0x000034, "Member 'UAbpLogicParams::BeHitAnimRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, EnterFkRef) == 0x000038, "Member 'UAbpLogicParams::EnterFkRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, DoubleHitInAirRef) == 0x000039, "Member 'UAbpLogicParams::DoubleHitInAirRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitDirectRef) == 0x00003C, "Member 'UAbpLogicParams::BeHitDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitLocationRef) == 0x000048, "Member 'UAbpLogicParams::BeHitLocationRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BeHitSocketNameRef) == 0x000054, "Member 'UAbpLogicParams::BeHitSocketNameRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharMoveStateRef) == 0x000060, "Member 'UAbpLogicParams::CharMoveStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharPositionStateRef) == 0x000061, "Member 'UAbpLogicParams::CharPositionStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, CharCameraStateRef) == 0x000062, "Member 'UAbpLogicParams::CharCameraStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, BattleIdleTimeRef) == 0x000064, "Member 'UAbpLogicParams::BattleIdleTimeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, DegMovementSlopeRef) == 0x000068, "Member 'UAbpLogicParams::DegMovementSlopeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SightDirectRef) == 0x00006C, "Member 'UAbpLogicParams::SightDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, RagQuitStateRef) == 0x000078, "Member 'UAbpLogicParams::RagQuitStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsJumpRef) == 0x000079, "Member 'UAbpLogicParams::IsJumpRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, AccelerationRef) == 0x00007C, "Member 'UAbpLogicParams::AccelerationRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsMovingRef) == 0x000088, "Member 'UAbpLogicParams::IsMovingRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SpeedRef) == 0x00008C, "Member 'UAbpLogicParams::SpeedRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, InputDirectRef) == 0x000090, "Member 'UAbpLogicParams::InputDirectRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, InputRotatorRef) == 0x00009C, "Member 'UAbpLogicParams::InputRotatorRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, IsFallingIntoWaterRef) == 0x0000A8, "Member 'UAbpLogicParams::IsFallingIntoWaterRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, GroundedTimeRef) == 0x0000AC, "Member 'UAbpLogicParams::GroundedTimeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, HasMoveInputRef) == 0x0000B0, "Member 'UAbpLogicParams::HasMoveInputRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbInfoRef) == 0x0000B4, "Member 'UAbpLogicParams::ClimbInfoRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbStateRef) == 0x0000C4, "Member 'UAbpLogicParams::ClimbStateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ClimbOnWallAngleRef) == 0x0000C8, "Member 'UAbpLogicParams::ClimbOnWallAngleRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SprintSwimOffsetRef) == 0x0000CC, "Member 'UAbpLogicParams::SprintSwimOffsetRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SprintSwimOffsetLerpSpeedRef) == 0x0000D0, "Member 'UAbpLogicParams::SprintSwimOffsetLerpSpeedRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideForwardRef) == 0x0000D4, "Member 'UAbpLogicParams::SlideForwardRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideSwitchThisFrameRef) == 0x0000E0, "Member 'UAbpLogicParams::SlideSwitchThisFrameRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SlideStandModeRef) == 0x0000E1, "Member 'UAbpLogicParams::SlideStandModeRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, JumpUpRateRef) == 0x0000E4, "Member 'UAbpLogicParams::JumpUpRateRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, ForceExitStateStopRef) == 0x0000E8, "Member 'UAbpLogicParams::ForceExitStateStopRef' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SkillTarget) == 0x0000F0, "Member 'UAbpLogicParams::SkillTarget' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, LastActiveSkillTime) == 0x0000F8, "Member 'UAbpLogicParams::LastActiveSkillTime' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, SitDownDirect) == 0x0000FC, "Member 'UAbpLogicParams::SitDownDirect' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, StandUpDirect) == 0x000100, "Member 'UAbpLogicParams::StandUpDirect' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bSitDown) == 0x000104, "Member 'UAbpLogicParams::bSitDown' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInPerformingPlot) == 0x000105, "Member 'UAbpLogicParams::bIsInPerformingPlot' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInSequence) == 0x000106, "Member 'UAbpLogicParams::bIsInSequence' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInSplineMove) == 0x000107, "Member 'UAbpLogicParams::bIsInSplineMove' has a wrong offset!");
static_assert(offsetof(UAbpLogicParams, bIsInUiCamera) == 0x000108, "Member 'UAbpLogicParams::bIsInUiCamera' has a wrong offset!");

// Class KuroAnim.KuroAnimInstanceRole
// 0x0310 (0x0860 - 0x0550)
class UKuroAnimInstanceRole : public UKuroAnimInstanceChar
{
public:
	int32                                         PerformanceTypeCount;                              // 0x0550(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF2[0x1C];                                    // 0x0554(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanbeInterrupt;                                   // 0x0570(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveBlock;                                        // 0x0571(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF3[0x2];                                     // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSeconds;                                       // 0x0574(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF4[0x4];                                     // 0x0578(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsNotNPC;                                         // 0x057C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF5[0x3];                                     // 0x057D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeRoleCount;                                   // 0x0580(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF6[0x1];                                     // 0x0584(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasNPCTag;                                        // 0x0585(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGoingToMove;                                    // 0x0586(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF7[0x5];                                     // 0x0587(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnMix;                                           // 0x058C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVeloctiyBlend                         SpeedMix;                                          // 0x0590(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AimMoveMix;                                        // 0x05A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAccel;                                        // 0x05A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLeanAmount                            LeanAmount;                                        // 0x05B4(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirection                                MoveDirection;                                     // 0x05BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF8[0x3];                                     // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundMovePlayRate;                                // 0x05C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunMix;                                        // 0x05C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSizeMix;                                       // 0x05C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVeloctiyBlend                         AccelLerpMix;                                      // 0x05CC(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x05DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x05E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFightStand;                                     // 0x05E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF9[0x3];                                     // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MoveMix;                                           // 0x05E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachePercentLR;                                    // 0x05F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachePercentFB;                                    // 0x05F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStandTurnType                                StandTurnType;                                     // 0x05F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFA[0x3];                                     // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LandSpeedIndex;                                    // 0x05FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingSpeed;                                      // 0x0600(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForecastLandWeight;                                // 0x0604(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AirVelocity;                                       // 0x0608(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirTargetYaw;                                      // 0x0614(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlideMix;                                          // 0x0618(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideMix;                                          // 0x0624(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFB[0x18];                                    // 0x0628(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirSlideMix;                                       // 0x0640(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HookRopeMix;                                       // 0x064C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HookRopeSucceedSpeed;                              // 0x0658(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFC[0x3];                                     // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpMix;                                           // 0x065C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SwimRootOffset;                                    // 0x0660(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimAccelOffset;                                   // 0x066C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimAccelOffsetReal;                               // 0x0670(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimMix;                                           // 0x0674(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastClimbMix;                                      // 0x0678(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbBrakeMix;                                     // 0x067C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimbMoving;                                    // 0x0680(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFD[0x3];                                     // 0x0681(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbRadius;                                       // 0x0684(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClimbDirection;                                    // 0x0688(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidClimbDirection;                               // 0x068C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroHumanIKMode                              IKMode;                                            // 0x0690(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIKNoLerp;                                         // 0x0691(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFE[0x2];                                     // 0x0692(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ComprehensiveRotator;                              // 0x0694(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BeHitStandardizedDirect;                           // 0x06A0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeHitSocketLocation;                               // 0x06AC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightLockAlpha;                                    // 0x06B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightLockDirect;                                   // 0x06BC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAimShotEnd;                                     // 0x06C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AFF[0x3];                                     // 0x06C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimYawMix;                                         // 0x06CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreezeCountDown;                                   // 0x06D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateStop;                                        // 0x06D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSprintStop;                                  // 0x06D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRunStop;                                     // 0x06D6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWalkStop;                                    // 0x06D7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGround;                                      // 0x06D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateStand;                                       // 0x06D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundSprint;                                // 0x06DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundRun;                                   // 0x06DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGroundWalk;                                  // 0x06DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateClimb;                                       // 0x06DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAir;                                         // 0x06DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSki;                                         // 0x06DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateNormalSki;                                   // 0x06E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirSlide;                                    // 0x06E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirGlide;                                    // 0x06E2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWater;                                       // 0x06E3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSkill;                                       // 0x06E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLockDirection;                               // 0x06E5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAimDirection;                                // 0x06E6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFaceDirection;                               // 0x06E7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBeHit;                                       // 0x06E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateHitPush;                                     // 0x06E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBeHitFly;                                    // 0x06EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateDying;                                       // 0x06EB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateDrown;                                       // 0x06EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateInBattle;                                    // 0x06ED(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateEnterBattle;                                 // 0x06EE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateKeepSprint;                                  // 0x06EF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFastSwim;                                    // 0x06F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateSit;                                         // 0x06F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateOverlapBaseAnim;                             // 0x06F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdditive;                                      // 0x06F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverlapLayerAdditive;                          // 0x06F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLowerRightTurnBlending;                      // 0x06F5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLowerBlending;                               // 0x06F6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateWholeBodyBlend;                              // 0x06F7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateUseSpecialStateMachine;                      // 0x06F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFastBlend;                                   // 0x06F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B00[0x2];                                     // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBlendAlpha;                                   // 0x06FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaPelvis;                                  // 0x0700(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaSpine;                                   // 0x070C(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaHead;                                    // 0x0718(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaArmL;                                    // 0x0724(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaArmR;                                    // 0x0730(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAdditiveBlendAlpha                    BlendAlphaLeg;                                     // 0x073C(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStateCast;                                        // 0x0748(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastThrowing;                                // 0x0749(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastSelecting;                               // 0x074A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateCastCasting;                                 // 0x074B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateMoveShot;                                    // 0x074C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateHoldShot;                                    // 0x074D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAiming;                                      // 0x074E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateGeneralAiming;                               // 0x074F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateShotNotify;                                  // 0x0750(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateFixHook;                                     // 0x0751(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShot;                               // 0x0752(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotLeft;                           // 0x0753(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotRight;                          // 0x0754(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateAirNormalShotFall;                           // 0x0755(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateBurst;                                       // 0x0756(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateInBurst;                                     // 0x0757(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLimitForward;                                // 0x0758(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateLimitBackward;                               // 0x0759(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandRollWhenDying;                                // 0x075A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaught;                                           // 0x075B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagDollQuit;                                      // 0x075C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B01[0x3];                                     // 0x075D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpresionAlpha;                                    // 0x0760(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B02[0x8];                                     // 0x0764(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEpresion;                                         // 0x076C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B03[0x3];                                     // 0x076D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PerformanceCountDown;                              // 0x0770(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformance;                                      // 0x0774(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B04[0x3];                                     // 0x0775(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PerformanceIndex;                                  // 0x0778(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPerformance;                                 // 0x077C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptNewSkill;                                   // 0x077D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B05[0x6];                                     // 0x077E(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStageMotionSki;                                   // 0x0784(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHugeItemPull;                                     // 0x0785(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHugeItemPullAngle;                                // 0x0786(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B06[0x1];                                     // 0x0787(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SizeToCharHeightMap;                               // 0x0788(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              LandSpeedThresholds;                               // 0x07D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMixLerp;                                      // 0x07E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundLeanLerp;                                    // 0x07E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimWalkSpeed;                                     // 0x07E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimRunSpeed;                                      // 0x07EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSprintSpeed;                                   // 0x07F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirLeanLerp;                                       // 0x07F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMixLerp;                                       // 0x07F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRotateLerp;                                   // 0x07FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRotateLerp2;                                  // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B07[0x4];                                     // 0x0804(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StandWalkStepCurve;                                // 0x0808(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StandRunStepCurve;                                 // 0x0810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ForecastLandCurve;                                 // 0x0818(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RelativeSpeedBlendCurve;                           // 0x0820(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AirLeanCurve;                                      // 0x0828(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngelToStepLengthCurve;                            // 0x0830(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AngleToStepFrequencyCurve;                         // 0x0838(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             FkMaterialControllerData;                          // 0x0840(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B08[0x18];                                    // 0x0848(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceRole">();
	}
	static class UKuroAnimInstanceRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceRole>();
	}
};
static_assert(alignof(UKuroAnimInstanceRole) == 0x000010, "Wrong alignment on UKuroAnimInstanceRole");
static_assert(sizeof(UKuroAnimInstanceRole) == 0x000860, "Wrong size on UKuroAnimInstanceRole");
static_assert(offsetof(UKuroAnimInstanceRole, PerformanceTypeCount) == 0x000550, "Member 'UKuroAnimInstanceRole::PerformanceTypeCount' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bCanbeInterrupt) == 0x000570, "Member 'UKuroAnimInstanceRole::bCanbeInterrupt' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bMoveBlock) == 0x000571, "Member 'UKuroAnimInstanceRole::bMoveBlock' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, TimeSeconds) == 0x000574, "Member 'UKuroAnimInstanceRole::TimeSeconds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsNotNPC) == 0x00057C, "Member 'UKuroAnimInstanceRole::bIsNotNPC' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ChangeRoleCount) == 0x000580, "Member 'UKuroAnimInstanceRole::ChangeRoleCount' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHasNPCTag) == 0x000585, "Member 'UKuroAnimInstanceRole::bHasNPCTag' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsGoingToMove) == 0x000586, "Member 'UKuroAnimInstanceRole::bIsGoingToMove' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, TurnMix) == 0x00058C, "Member 'UKuroAnimInstanceRole::TurnMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SpeedMix) == 0x000590, "Member 'UKuroAnimInstanceRole::SpeedMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimMoveMix) == 0x0005A0, "Member 'UKuroAnimInstanceRole::AimMoveMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LocalAccel) == 0x0005A8, "Member 'UKuroAnimInstanceRole::LocalAccel' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LeanAmount) == 0x0005B4, "Member 'UKuroAnimInstanceRole::LeanAmount' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, MoveDirection) == 0x0005BC, "Member 'UKuroAnimInstanceRole::MoveDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GroundMovePlayRate) == 0x0005C0, "Member 'UKuroAnimInstanceRole::GroundMovePlayRate' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, WalkRunMix) == 0x0005C4, "Member 'UKuroAnimInstanceRole::WalkRunMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StepSizeMix) == 0x0005C8, "Member 'UKuroAnimInstanceRole::StepSizeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AccelLerpMix) == 0x0005CC, "Member 'UKuroAnimInstanceRole::AccelLerpMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimYaw) == 0x0005DC, "Member 'UKuroAnimInstanceRole::AimYaw' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimPitch) == 0x0005E0, "Member 'UKuroAnimInstanceRole::AimPitch' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsFightStand) == 0x0005E4, "Member 'UKuroAnimInstanceRole::bIsFightStand' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, MoveMix) == 0x0005E8, "Member 'UKuroAnimInstanceRole::MoveMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, CachePercentLR) == 0x0005F0, "Member 'UKuroAnimInstanceRole::CachePercentLR' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, CachePercentFB) == 0x0005F4, "Member 'UKuroAnimInstanceRole::CachePercentFB' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandTurnType) == 0x0005F8, "Member 'UKuroAnimInstanceRole::StandTurnType' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LandSpeedIndex) == 0x0005FC, "Member 'UKuroAnimInstanceRole::LandSpeedIndex' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FallingSpeed) == 0x000600, "Member 'UKuroAnimInstanceRole::FallingSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ForecastLandWeight) == 0x000604, "Member 'UKuroAnimInstanceRole::ForecastLandWeight' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirVelocity) == 0x000608, "Member 'UKuroAnimInstanceRole::AirVelocity' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirTargetYaw) == 0x000614, "Member 'UKuroAnimInstanceRole::AirTargetYaw' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GlideMix) == 0x000618, "Member 'UKuroAnimInstanceRole::GlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideMix) == 0x000624, "Member 'UKuroAnimInstanceRole::SlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirSlideMix) == 0x000640, "Member 'UKuroAnimInstanceRole::AirSlideMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, HookRopeMix) == 0x00064C, "Member 'UKuroAnimInstanceRole::HookRopeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, HookRopeSucceedSpeed) == 0x000658, "Member 'UKuroAnimInstanceRole::HookRopeSucceedSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, JumpMix) == 0x00065C, "Member 'UKuroAnimInstanceRole::JumpMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimRootOffset) == 0x000660, "Member 'UKuroAnimInstanceRole::SwimRootOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimAccelOffset) == 0x00066C, "Member 'UKuroAnimInstanceRole::SwimAccelOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimAccelOffsetReal) == 0x000670, "Member 'UKuroAnimInstanceRole::SwimAccelOffsetReal' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SwimMix) == 0x000674, "Member 'UKuroAnimInstanceRole::SwimMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FastClimbMix) == 0x000678, "Member 'UKuroAnimInstanceRole::FastClimbMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbBrakeMix) == 0x00067C, "Member 'UKuroAnimInstanceRole::ClimbBrakeMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIsClimbMoving) == 0x000680, "Member 'UKuroAnimInstanceRole::bIsClimbMoving' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbRadius) == 0x000684, "Member 'UKuroAnimInstanceRole::ClimbRadius' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ClimbDirection) == 0x000688, "Member 'UKuroAnimInstanceRole::ClimbDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ValidClimbDirection) == 0x00068C, "Member 'UKuroAnimInstanceRole::ValidClimbDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, IKMode) == 0x000690, "Member 'UKuroAnimInstanceRole::IKMode' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bIKNoLerp) == 0x000691, "Member 'UKuroAnimInstanceRole::bIKNoLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ComprehensiveRotator) == 0x000694, "Member 'UKuroAnimInstanceRole::ComprehensiveRotator' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BeHitStandardizedDirect) == 0x0006A0, "Member 'UKuroAnimInstanceRole::BeHitStandardizedDirect' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BeHitSocketLocation) == 0x0006AC, "Member 'UKuroAnimInstanceRole::BeHitSocketLocation' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SightLockAlpha) == 0x0006B8, "Member 'UKuroAnimInstanceRole::SightLockAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SightLockDirect) == 0x0006BC, "Member 'UKuroAnimInstanceRole::SightLockDirect' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bInAimShotEnd) == 0x0006C8, "Member 'UKuroAnimInstanceRole::bInAimShotEnd' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AimYawMix) == 0x0006CC, "Member 'UKuroAnimInstanceRole::AimYawMix' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FreezeCountDown) == 0x0006D0, "Member 'UKuroAnimInstanceRole::FreezeCountDown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateStop) == 0x0006D4, "Member 'UKuroAnimInstanceRole::bStateStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSprintStop) == 0x0006D5, "Member 'UKuroAnimInstanceRole::bStateSprintStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateRunStop) == 0x0006D6, "Member 'UKuroAnimInstanceRole::bStateRunStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWalkStop) == 0x0006D7, "Member 'UKuroAnimInstanceRole::bStateWalkStop' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGround) == 0x0006D8, "Member 'UKuroAnimInstanceRole::bStateGround' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateStand) == 0x0006D9, "Member 'UKuroAnimInstanceRole::bStateStand' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundSprint) == 0x0006DA, "Member 'UKuroAnimInstanceRole::bStateGroundSprint' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundRun) == 0x0006DB, "Member 'UKuroAnimInstanceRole::bStateGroundRun' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGroundWalk) == 0x0006DC, "Member 'UKuroAnimInstanceRole::bStateGroundWalk' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateClimb) == 0x0006DD, "Member 'UKuroAnimInstanceRole::bStateClimb' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAir) == 0x0006DE, "Member 'UKuroAnimInstanceRole::bStateAir' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSki) == 0x0006DF, "Member 'UKuroAnimInstanceRole::bStateSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateNormalSki) == 0x0006E0, "Member 'UKuroAnimInstanceRole::bStateNormalSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirSlide) == 0x0006E1, "Member 'UKuroAnimInstanceRole::bStateAirSlide' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirGlide) == 0x0006E2, "Member 'UKuroAnimInstanceRole::bStateAirGlide' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWater) == 0x0006E3, "Member 'UKuroAnimInstanceRole::bStateWater' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSkill) == 0x0006E4, "Member 'UKuroAnimInstanceRole::bStateSkill' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLockDirection) == 0x0006E5, "Member 'UKuroAnimInstanceRole::bStateLockDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAimDirection) == 0x0006E6, "Member 'UKuroAnimInstanceRole::bStateAimDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFaceDirection) == 0x0006E7, "Member 'UKuroAnimInstanceRole::bStateFaceDirection' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBeHit) == 0x0006E8, "Member 'UKuroAnimInstanceRole::bStateBeHit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateHitPush) == 0x0006E9, "Member 'UKuroAnimInstanceRole::bStateHitPush' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBeHitFly) == 0x0006EA, "Member 'UKuroAnimInstanceRole::bStateBeHitFly' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateDying) == 0x0006EB, "Member 'UKuroAnimInstanceRole::bStateDying' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateDrown) == 0x0006EC, "Member 'UKuroAnimInstanceRole::bStateDrown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateInBattle) == 0x0006ED, "Member 'UKuroAnimInstanceRole::bStateInBattle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateEnterBattle) == 0x0006EE, "Member 'UKuroAnimInstanceRole::bStateEnterBattle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateKeepSprint) == 0x0006EF, "Member 'UKuroAnimInstanceRole::bStateKeepSprint' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFastSwim) == 0x0006F0, "Member 'UKuroAnimInstanceRole::bStateFastSwim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateSit) == 0x0006F1, "Member 'UKuroAnimInstanceRole::bStateSit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateOverlapBaseAnim) == 0x0006F2, "Member 'UKuroAnimInstanceRole::bStateOverlapBaseAnim' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bUseAdditive) == 0x0006F3, "Member 'UKuroAnimInstanceRole::bUseAdditive' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bUseOverlapLayerAdditive) == 0x0006F4, "Member 'UKuroAnimInstanceRole::bUseOverlapLayerAdditive' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLowerRightTurnBlending) == 0x0006F5, "Member 'UKuroAnimInstanceRole::bStateLowerRightTurnBlending' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLowerBlending) == 0x0006F6, "Member 'UKuroAnimInstanceRole::bStateLowerBlending' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateWholeBodyBlend) == 0x0006F7, "Member 'UKuroAnimInstanceRole::bStateWholeBodyBlend' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateUseSpecialStateMachine) == 0x0006F8, "Member 'UKuroAnimInstanceRole::bStateUseSpecialStateMachine' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFastBlend) == 0x0006F9, "Member 'UKuroAnimInstanceRole::bStateFastBlend' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LowerBlendAlpha) == 0x0006FC, "Member 'UKuroAnimInstanceRole::LowerBlendAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaPelvis) == 0x000700, "Member 'UKuroAnimInstanceRole::BlendAlphaPelvis' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaSpine) == 0x00070C, "Member 'UKuroAnimInstanceRole::BlendAlphaSpine' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaHead) == 0x000718, "Member 'UKuroAnimInstanceRole::BlendAlphaHead' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaArmL) == 0x000724, "Member 'UKuroAnimInstanceRole::BlendAlphaArmL' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaArmR) == 0x000730, "Member 'UKuroAnimInstanceRole::BlendAlphaArmR' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, BlendAlphaLeg) == 0x00073C, "Member 'UKuroAnimInstanceRole::BlendAlphaLeg' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCast) == 0x000748, "Member 'UKuroAnimInstanceRole::bStateCast' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastThrowing) == 0x000749, "Member 'UKuroAnimInstanceRole::bStateCastThrowing' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastSelecting) == 0x00074A, "Member 'UKuroAnimInstanceRole::bStateCastSelecting' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateCastCasting) == 0x00074B, "Member 'UKuroAnimInstanceRole::bStateCastCasting' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateMoveShot) == 0x00074C, "Member 'UKuroAnimInstanceRole::bStateMoveShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateHoldShot) == 0x00074D, "Member 'UKuroAnimInstanceRole::bStateHoldShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAiming) == 0x00074E, "Member 'UKuroAnimInstanceRole::bStateAiming' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateGeneralAiming) == 0x00074F, "Member 'UKuroAnimInstanceRole::bStateGeneralAiming' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateShotNotify) == 0x000750, "Member 'UKuroAnimInstanceRole::bStateShotNotify' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateFixHook) == 0x000751, "Member 'UKuroAnimInstanceRole::bStateFixHook' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShot) == 0x000752, "Member 'UKuroAnimInstanceRole::bStateAirNormalShot' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotLeft) == 0x000753, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotLeft' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotRight) == 0x000754, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotRight' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateAirNormalShotFall) == 0x000755, "Member 'UKuroAnimInstanceRole::bStateAirNormalShotFall' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateBurst) == 0x000756, "Member 'UKuroAnimInstanceRole::bStateBurst' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateInBurst) == 0x000757, "Member 'UKuroAnimInstanceRole::bStateInBurst' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLimitForward) == 0x000758, "Member 'UKuroAnimInstanceRole::bStateLimitForward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStateLimitBackward) == 0x000759, "Member 'UKuroAnimInstanceRole::bStateLimitBackward' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bLandRollWhenDying) == 0x00075A, "Member 'UKuroAnimInstanceRole::bLandRollWhenDying' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bCaught) == 0x00075B, "Member 'UKuroAnimInstanceRole::bCaught' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bRagDollQuit) == 0x00075C, "Member 'UKuroAnimInstanceRole::bRagDollQuit' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ExpresionAlpha) == 0x000760, "Member 'UKuroAnimInstanceRole::ExpresionAlpha' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bEpresion) == 0x00076C, "Member 'UKuroAnimInstanceRole::bEpresion' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, PerformanceCountDown) == 0x000770, "Member 'UKuroAnimInstanceRole::PerformanceCountDown' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bPerformance) == 0x000774, "Member 'UKuroAnimInstanceRole::bPerformance' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, PerformanceIndex) == 0x000778, "Member 'UKuroAnimInstanceRole::PerformanceIndex' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bAllowPerformance) == 0x00077C, "Member 'UKuroAnimInstanceRole::bAllowPerformance' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bAcceptNewSkill) == 0x00077D, "Member 'UKuroAnimInstanceRole::bAcceptNewSkill' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bStageMotionSki) == 0x000784, "Member 'UKuroAnimInstanceRole::bStageMotionSki' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHugeItemPull) == 0x000785, "Member 'UKuroAnimInstanceRole::bHugeItemPull' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, bHugeItemPullAngle) == 0x000786, "Member 'UKuroAnimInstanceRole::bHugeItemPullAngle' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SizeToCharHeightMap) == 0x000788, "Member 'UKuroAnimInstanceRole::SizeToCharHeightMap' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, LandSpeedThresholds) == 0x0007D8, "Member 'UKuroAnimInstanceRole::LandSpeedThresholds' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SpeedMixLerp) == 0x0007E0, "Member 'UKuroAnimInstanceRole::SpeedMixLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, GroundLeanLerp) == 0x0007E4, "Member 'UKuroAnimInstanceRole::GroundLeanLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimWalkSpeed) == 0x0007E8, "Member 'UKuroAnimInstanceRole::AnimWalkSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimRunSpeed) == 0x0007EC, "Member 'UKuroAnimInstanceRole::AnimRunSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AnimSprintSpeed) == 0x0007F0, "Member 'UKuroAnimInstanceRole::AnimSprintSpeed' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirLeanLerp) == 0x0007F4, "Member 'UKuroAnimInstanceRole::AirLeanLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, JumpMixLerp) == 0x0007F8, "Member 'UKuroAnimInstanceRole::JumpMixLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideRotateLerp) == 0x0007FC, "Member 'UKuroAnimInstanceRole::SlideRotateLerp' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, SlideRotateLerp2) == 0x000800, "Member 'UKuroAnimInstanceRole::SlideRotateLerp2' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandWalkStepCurve) == 0x000808, "Member 'UKuroAnimInstanceRole::StandWalkStepCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, StandRunStepCurve) == 0x000810, "Member 'UKuroAnimInstanceRole::StandRunStepCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, ForecastLandCurve) == 0x000818, "Member 'UKuroAnimInstanceRole::ForecastLandCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, RelativeSpeedBlendCurve) == 0x000820, "Member 'UKuroAnimInstanceRole::RelativeSpeedBlendCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AirLeanCurve) == 0x000828, "Member 'UKuroAnimInstanceRole::AirLeanCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AngelToStepLengthCurve) == 0x000830, "Member 'UKuroAnimInstanceRole::AngelToStepLengthCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, AngleToStepFrequencyCurve) == 0x000838, "Member 'UKuroAnimInstanceRole::AngleToStepFrequencyCurve' has a wrong offset!");
static_assert(offsetof(UKuroAnimInstanceRole, FkMaterialControllerData) == 0x000840, "Member 'UKuroAnimInstanceRole::FkMaterialControllerData' has a wrong offset!");

// Class KuroAnim.KuroAdjustableCapsuleComponent
// 0x0040 (0x0550 - 0x0510)
class UKuroAdjustableCapsuleComponent final : public UCapsuleComponent
{
public:
	TArray<class FName>                           BindSocketNames;                                   // 0x0508(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AddRadius;                                         // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdjustCapsuleType                            AdjustCapsuleType;                                 // 0x0524(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B09[0x2B];                                    // 0x0525(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAdjustableCapsuleComponent">();
	}
	static class UKuroAdjustableCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAdjustableCapsuleComponent>();
	}
};
static_assert(alignof(UKuroAdjustableCapsuleComponent) == 0x000010, "Wrong alignment on UKuroAdjustableCapsuleComponent");
static_assert(sizeof(UKuroAdjustableCapsuleComponent) == 0x000550, "Wrong size on UKuroAdjustableCapsuleComponent");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, BindSocketNames) == 0x000508, "Member 'UKuroAdjustableCapsuleComponent::BindSocketNames' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, AddRadius) == 0x000518, "Member 'UKuroAdjustableCapsuleComponent::AddRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, MinRadius) == 0x00051C, "Member 'UKuroAdjustableCapsuleComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, MaxRadius) == 0x000520, "Member 'UKuroAdjustableCapsuleComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UKuroAdjustableCapsuleComponent, AdjustCapsuleType) == 0x000524, "Member 'UKuroAdjustableCapsuleComponent::AdjustCapsuleType' has a wrong offset!");

// Class KuroAnim.KuroTrackRecorder
// 0x00E0 (0x0110 - 0x0030)
class UKuroTrackRecorder : public UObject
{
public:
	uint8                                         Pad_1B0A[0xE0];                                    // 0x0030(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGuid GetMainGuid();
	class AActor* GetShadow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrackRecorder">();
	}
	static class UKuroTrackRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrackRecorder>();
	}
};
static_assert(alignof(UKuroTrackRecorder) == 0x000008, "Wrong alignment on UKuroTrackRecorder");
static_assert(sizeof(UKuroTrackRecorder) == 0x000110, "Wrong size on UKuroTrackRecorder");

// Class KuroAnim.KuroCameraRecorder
// 0x0008 (0x0118 - 0x0110)
class UKuroCameraRecorder final : public UKuroTrackRecorder
{
public:
	uint8                                         Pad_1B0B[0x8];                                     // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCameraRecorder">();
	}
	static class UKuroCameraRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCameraRecorder>();
	}
};
static_assert(alignof(UKuroCameraRecorder) == 0x000008, "Wrong alignment on UKuroCameraRecorder");
static_assert(sizeof(UKuroCameraRecorder) == 0x000118, "Wrong size on UKuroCameraRecorder");

// Class KuroAnim.KuroAnimConfig
// 0x0008 (0x0038 - 0x0030)
class UKuroAnimConfig final : public UObject
{
public:
	float                                         DefaultFootOffset;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultHighHeelsOffset;                            // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimConfig">();
	}
	static class UKuroAnimConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimConfig>();
	}
};
static_assert(alignof(UKuroAnimConfig) == 0x000008, "Wrong alignment on UKuroAnimConfig");
static_assert(sizeof(UKuroAnimConfig) == 0x000038, "Wrong size on UKuroAnimConfig");
static_assert(offsetof(UKuroAnimConfig, DefaultFootOffset) == 0x000030, "Member 'UKuroAnimConfig::DefaultFootOffset' has a wrong offset!");
static_assert(offsetof(UKuroAnimConfig, DefaultHighHeelsOffset) == 0x000034, "Member 'UKuroAnimConfig::DefaultHighHeelsOffset' has a wrong offset!");

// Class KuroAnim.KuroAnimMathLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroAnimMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator LookRotation_ForwardFirst(const struct FVector& Forward, const struct FVector& Up);
	static struct FRotator LookRotation_UpFirst(const struct FVector& Forward, const struct FVector& Up);
	static struct FRotator Quat_FindBetween(const struct FVector& V1, const struct FVector& V2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimMathLibrary">();
	}
	static class UKuroAnimMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimMathLibrary>();
	}
};
static_assert(alignof(UKuroAnimMathLibrary) == 0x000008, "Wrong alignment on UKuroAnimMathLibrary");
static_assert(sizeof(UKuroAnimMathLibrary) == 0x000030, "Wrong size on UKuroAnimMathLibrary");

// Class KuroAnim.KuroAnimInstanceMonster
// 0x0000 (0x0550 - 0x0550)
class UKuroAnimInstanceMonster final : public UKuroAnimInstanceChar
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimInstanceMonster">();
	}
	static class UKuroAnimInstanceMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimInstanceMonster>();
	}
};
static_assert(alignof(UKuroAnimInstanceMonster) == 0x000010, "Wrong alignment on UKuroAnimInstanceMonster");
static_assert(sizeof(UKuroAnimInstanceMonster) == 0x000550, "Wrong size on UKuroAnimInstanceMonster");

// Class KuroAnim.KuroAnimJsSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UKuroAnimJsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1B0C[0x68];                                    // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimJsSubsystem">();
	}
	static class UKuroAnimJsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimJsSubsystem>();
	}
};
static_assert(alignof(UKuroAnimJsSubsystem) == 0x000008, "Wrong alignment on UKuroAnimJsSubsystem");
static_assert(sizeof(UKuroAnimJsSubsystem) == 0x0000A0, "Wrong size on UKuroAnimJsSubsystem");

// Class KuroAnim.KuroAnimLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroAnimLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EndAnimNotifyStates(class UAnimInstance* AnimInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimLibrary">();
	}
	static class UKuroAnimLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimLibrary>();
	}
};
static_assert(alignof(UKuroAnimLibrary) == 0x000008, "Wrong alignment on UKuroAnimLibrary");
static_assert(sizeof(UKuroAnimLibrary) == 0x000030, "Wrong size on UKuroAnimLibrary");

// Class KuroAnim.KuroCameraShake
// 0x0030 (0x01D0 - 0x01A0)
class UKuroCameraShake : public UMatineeCameraShake
{
public:
	EAlphaBlendOption                             BlendInMode;                                       // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0D[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendInCustomCurve;                                // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendOutMode;                                      // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0E[0x7];                                     // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendOutCustomCurve;                               // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsUseCurveVector : 1;                             // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B0F[0x7];                                     // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           BlendCurveVector;                                  // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B10[0x8];                                     // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCameraShake">();
	}
	static class UKuroCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCameraShake>();
	}
};
static_assert(alignof(UKuroCameraShake) == 0x000010, "Wrong alignment on UKuroCameraShake");
static_assert(sizeof(UKuroCameraShake) == 0x0001D0, "Wrong size on UKuroCameraShake");
static_assert(offsetof(UKuroCameraShake, BlendInMode) == 0x000198, "Member 'UKuroCameraShake::BlendInMode' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendInCustomCurve) == 0x0001A0, "Member 'UKuroCameraShake::BlendInCustomCurve' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendOutMode) == 0x0001A8, "Member 'UKuroCameraShake::BlendOutMode' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendOutCustomCurve) == 0x0001B0, "Member 'UKuroCameraShake::BlendOutCustomCurve' has a wrong offset!");
static_assert(offsetof(UKuroCameraShake, BlendCurveVector) == 0x0001C0, "Member 'UKuroCameraShake::BlendCurveVector' has a wrong offset!");

// Class KuroAnim.KuroCharacterRecorder
// 0x0008 (0x0118 - 0x0110)
class UKuroCharacterRecorder final : public UKuroTrackRecorder
{
public:
	bool                                          bUseClone;                                         // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B11[0x7];                                     // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCharacterRecorder">();
	}
	static class UKuroCharacterRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCharacterRecorder>();
	}
};
static_assert(alignof(UKuroCharacterRecorder) == 0x000008, "Wrong alignment on UKuroCharacterRecorder");
static_assert(sizeof(UKuroCharacterRecorder) == 0x000118, "Wrong size on UKuroCharacterRecorder");
static_assert(offsetof(UKuroCharacterRecorder, bUseClone) == 0x000110, "Member 'UKuroCharacterRecorder::bUseClone' has a wrong offset!");

// Class KuroAnim.KuroEffectRecorder
// 0x0000 (0x0110 - 0x0110)
class UKuroEffectRecorder final : public UKuroTrackRecorder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectRecorder">();
	}
	static class UKuroEffectRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectRecorder>();
	}
};
static_assert(alignof(UKuroEffectRecorder) == 0x000008, "Wrong alignment on UKuroEffectRecorder");
static_assert(sizeof(UKuroEffectRecorder) == 0x000110, "Wrong size on UKuroEffectRecorder");

// Class KuroAnim.KuroMeshRecorder
// 0x0000 (0x0110 - 0x0110)
class UKuroMeshRecorder final : public UKuroTrackRecorder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMeshRecorder">();
	}
	static class UKuroMeshRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMeshRecorder>();
	}
};
static_assert(alignof(UKuroMeshRecorder) == 0x000008, "Wrong alignment on UKuroMeshRecorder");
static_assert(sizeof(UKuroMeshRecorder) == 0x000110, "Wrong size on UKuroMeshRecorder");

// Class KuroAnim.KuroRecordCharacter
// 0x0050 (0x02F8 - 0x02A8)
class AKuroRecordCharacter final : public AActor
{
public:
	class USceneComponent*                        MainScene;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh0;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh1;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh2;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh3;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh4;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh5;                                          // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh6;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh7;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SubMesh8;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecordCharacter">();
	}
	static class AKuroRecordCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRecordCharacter>();
	}
};
static_assert(alignof(AKuroRecordCharacter) == 0x000008, "Wrong alignment on AKuroRecordCharacter");
static_assert(sizeof(AKuroRecordCharacter) == 0x0002F8, "Wrong size on AKuroRecordCharacter");
static_assert(offsetof(AKuroRecordCharacter, MainScene) == 0x0002A8, "Member 'AKuroRecordCharacter::MainScene' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh0) == 0x0002B0, "Member 'AKuroRecordCharacter::SubMesh0' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh1) == 0x0002B8, "Member 'AKuroRecordCharacter::SubMesh1' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh2) == 0x0002C0, "Member 'AKuroRecordCharacter::SubMesh2' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh3) == 0x0002C8, "Member 'AKuroRecordCharacter::SubMesh3' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh4) == 0x0002D0, "Member 'AKuroRecordCharacter::SubMesh4' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh5) == 0x0002D8, "Member 'AKuroRecordCharacter::SubMesh5' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh6) == 0x0002E0, "Member 'AKuroRecordCharacter::SubMesh6' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh7) == 0x0002E8, "Member 'AKuroRecordCharacter::SubMesh7' has a wrong offset!");
static_assert(offsetof(AKuroRecordCharacter, SubMesh8) == 0x0002F0, "Member 'AKuroRecordCharacter::SubMesh8' has a wrong offset!");

// Class KuroAnim.KuroRecordEffect
// 0x0000 (0x02A8 - 0x02A8)
class AKuroRecordEffect : public AActor
{
public:
	void OnPlay();
	void OnStop();
	void Play();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecordEffect">();
	}
	static class AKuroRecordEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRecordEffect>();
	}
};
static_assert(alignof(AKuroRecordEffect) == 0x000008, "Wrong alignment on AKuroRecordEffect");
static_assert(sizeof(AKuroRecordEffect) == 0x0002A8, "Wrong size on AKuroRecordEffect");

// Class KuroAnim.KuroRecorderLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroRecorderLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGuid CopyLevelSequence(class ULevelSequence* SourceSequence, class ULevelSequence* TargetSequence, float TimeOffset, const TMap<class FName, struct FGuid>& RetargetAttached, const TSet<class UClass*>& IgnoreClasses, const struct FTransform& StartTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRecorderLibrary">();
	}
	static class UKuroRecorderLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRecorderLibrary>();
	}
};
static_assert(alignof(UKuroRecorderLibrary) == 0x000008, "Wrong alignment on UKuroRecorderLibrary");
static_assert(sizeof(UKuroRecorderLibrary) == 0x000030, "Wrong size on UKuroRecorderLibrary");

}

